= Data model setup

:sourcedir: ../../main/java/com/timvero/example/admin
:migrationdir: ../../main/resources/db/migration

This section describes how to set up and manage the data model using SQL file autogeneration and Flyway migrations.

== SQL File Autogeneration

The platform automatically generates SQL files based on your entity definitions. This process creates the necessary database schema files that can be used with Flyway for database migrations.

=== Automatic Generation Process

After the class is configured, run the application. The system will analyze changes in the data model of Java classes and generate an SQL script with the necessary changes `V241012192920.sql` in the project's home directory (`application.home=_path_`), in the subdirectory `hbm2ddl`.

The generation process works as follows:

1. **Entity Analysis**: The system scans all JPA entity classes for changes
2. **Schema Comparison**: Compares current entity definitions with the existing database schema
3. **SQL Generation**: Creates appropriate DDL statements (CREATE, ALTER, DROP) for detected changes
4. **File Creation**: Generates timestamped migration files in the `hbm2ddl` directory
5. **Migration Integration**: Files can be moved to Flyway migration directory for deployment

=== Entity Definition Example

Let's look at the `Participant` entity as an example:

[source,java]
----
include::{sourcedir}/participant/entity/Participant.java[tags=entity]
    // getters and setters...
}
----

=== Enum Definitions

The entity uses several enums that define the possible values:

.ParticipantStatus enum
[source,java]
----
include::{sourcedir}/participant/entity/ParticipantStatus.java[tags=enum]
----

.Employment enum
[source,java]
----
include::{sourcedir}/participant/entity/Employment.java[tags=enum]
----

.Periodicity enum
[source,java]
----
include::{sourcedir}/participant/entity/Periodicity.java[tags=enum]
----

== Flyway Migration Integration

=== Migration File Structure

Flyway migration files are stored in the `src/main/resources/db/migration/` directory and follow the naming convention:

----
V{version}__{description}.sql
----

For example:
----
V250530170222__init.sql
V250609220043__participantStatus.sql
----

=== Generated SQL Example

Based on the `Participant` entity definition, the system generates the following SQL:

[source,sql]
----
include::{migrationdir}/V250530170222__init.sql[tags=participant-table]
----

=== Migration Workflow

1. **Entity Definition**: Define your entity classes with appropriate JPA annotations
2. **Application Execution**: Run the application to trigger the automatic analysis process
3. **SQL Autogeneration**: The platform analyzes entity changes and generates SQL scripts in the `hbm2ddl` subdirectory
4. **Migration File Preparation**: Move generated SQL files from `hbm2ddl` to the Flyway migration directory (`src/main/resources/db/migration/`)
5. **File Naming**: Rename files to follow Flyway convention: `V{version}__{description}.sql`
6. **Flyway Execution**: During application startup, Flyway executes pending migrations in version order
7. **Schema Versioning**: Database schema version is tracked automatically in the `schema_version` table

=== Best Practices

* **Incremental Changes**: Create separate migration files for each schema change
* **Descriptive Names**: Use clear, descriptive names for migration files
* **Testing**: Test migrations on development environments before production
* **Rollback Strategy**: Consider rollback scenarios when designing schema changes

=== Migration File Example

Here's an actual migration file that adds participant status functionality:

.V250609220043__participantStatus.sql
[source,sql]
----
include::{migrationdir}/V250609220043__participantStatus.sql[tags=add-status-column]
----

This approach ensures that your database schema evolves in a controlled, versioned manner while maintaining data integrity throughout the development lifecycle.

== Troubleshooting Data Model Issues

=== SQL Generation Problems

==== No SQL Files Generated

**Problem**: Need to generate SQL migration files but no files appear in `hbm2ddl` directory

**Solution**:

1. **Check application.home property**:
+
```properties
# In application.properties
application.home=/path/to/your/project
# Or use relative path
application.home=.
```

2. **Verify entities are detected**:
+
```java
// Ensure entities have proper annotations
@Entity
@Table(name = "your_table_name")
public class YourEntity extends AbstractAuditable<UUID> {
}
```

3. **Check entity scanning configuration**:
+
```java
// Ensure entities are in scanned packages
@EntityScan(basePackages = {"com.yourpackage.entity"})
@SpringBootApplication
public class Application {
}
```

=== Flyway Migration Issues

==== Wrong Migration Order

**Problem**: Migrations execute in wrong order due to versioning issues

**Solution**:

1. **Check version numbering**:
+
```
# Correct format: VyyyyMMddHHmmss__description.sql
V250610120000__add_participant_status.sql
V250610130000__add_participant_employment.sql

# Wrong (will execute in wrong order):
V1__add_status.sql
V10__add_employment.sql  # This executes before V2!
```

2. **Use consistent timestamp format**:
+
```bash
# Generate timestamp for new migration
date +"%y%m%d%H%M%S"
# Use this in filename: V250610143022__your_description.sql
```

3. **Fix ordering with new migration**:
+
```sql
-- If wrong order was applied, create corrective migration
-- V250610150000__correct_previous_changes.sql
```

=== Database Connection Issues

==== Connection Pool Exhaustion

**Problem**: `HikariPool: Connection is not available` errors

**Solution**:

1. **Check connection pool settings**:
+
```properties
# In application.properties
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.idle-timeout=300000
```

2. **Monitor connection usage**:
+
```properties
# Enable connection pool metrics
spring.datasource.hikari.register-mbeans=true
management.endpoints.web.exposure.include=metrics
```

3. **Check for connection leaks**:
+
```java
// Ensure @Transactional is used properly
@Service
@Transactional  // This ensures connections are properly closed
public class YourService {
}
```

==== Database Lock Issues

**Problem**: Migrations hang or fail with lock timeout errors

**Solution**:

1. **Check for long-running transactions**:
+
```sql
-- PostgreSQL: Find blocking queries
SELECT pid, usename, application_name, state, query 
FROM pg_stat_activity 
WHERE state != 'idle' ORDER BY query_start;
```

2. **Kill blocking sessions (carefully)**:
+
```sql
-- Terminate specific session
SELECT pg_terminate_backend(12345);  -- Replace with actual PID
```

=== Performance Issues

==== Slow Entity Loading

**Problem**: Entity queries are slow or cause N+1 query problems

**Solution**:

1. **Add database indexes using Hibernate annotations**:
+
```java
@Entity
@Table(name = "participants", indexes = {
    @Index(name = "idx_participants_status", columnList = "status"),
    @Index(name = "idx_participants_employment", columnList = "employment"),
    @Index(name = "idx_participants_application_id", columnList = "application_id")
})
public class Participant extends AbstractAuditable<UUID> {
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status")
    private ParticipantStatus status;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "employment")
    private Employment employment;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "application_id")
    private Application application;
}
```
+
**Alternative: Add indexes via migration file**:
+
```sql
-- V250610120000__add_performance_indexes.sql
CREATE INDEX idx_participants_status ON participants(status);
CREATE INDEX idx_participants_employment ON participants(employment);
CREATE INDEX idx_participants_application_id ON participants(application_id);
```

2. **Use proper fetch strategies**:
+
```java
@Entity
public class Participant {
    @ManyToOne(fetch = FetchType.LAZY)  // Don't use EAGER unless necessary
    private Application application;
    
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "participant")
    private List<Document> documents;
}
```

3. **Enable query logging to diagnose**:
+
```properties
# In application.properties (development only)
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.SQL=DEBUG
```
