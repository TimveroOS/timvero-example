= Entity Checkers — setup & usage

:sourcedir: ../../main/java/com/timvero/example/admin
:templatedir: ../../main/resources/templates

This section describes how to set up and manage Entity Checkers for automated business rule validation and state management in the application.

== Checker System Architecture

The platform uses Entity Checkers to implement event-driven business logic that automatically responds to entity changes. Checkers are reactive components that listen to DB changes and execute rules when conditions are met.

=== What are Entity Checkers?

[.unstyled]
* {ok} **Monitor Entity Changes** — detect create/update/delete of entities
* {ok} **Apply Business Rules** — execute predefined logic on matched conditions
* {ok} **Maintain Data Consistency** — keep related entities in sync
* {ok} **Automate Workflows** — trigger next steps without manual actions

=== Checker Class Hierarchy

[.unstyled]
* {ok} **Base Checker Classes** — framework abstract classes (e.g. `EntityChecker`) provide infrastructure
* {ok} **Custom Entity Checkers** — app-specific implementations
e.g. `BorrowerStartTreeChecker` — manages borrower workflow start

Each checker has three core parts:

[.unstyled]
* {ok} **<<listener-registration,Listener Registration>>** (`registerListeners`) — what changes to monitor
* {ok} **Availability Check** (`isAvailable`) — when the checker should run
* {ok} **Business Logic** (`perform`) — what to do if available

== Listener Registration

`registerListeners` defines which changes trigger the checker, configured via `CheckerListenerRegistry`.

=== CheckerListenerRegistry

`CheckerListenerRegistry<E>` configures listeners for entity changes where `E` is the target entity type (e.g., `Application`, `Participant`).

[cols="1,2,3",options="header"]
|===
|Method |Parameters |Description

|`entityChange`
|`Class<T> entityClass` — entity being monitored +
`Function<T,E> mapper` — map changed entity to target
|Create a listener for changes on a *different* type. See <<using-entitychange-method>>.

|`entityChange`
|_(none)_
|Monitor the *same* entity type as the checker (shorthand).

|`updated`
|`String... fields`
|Filter to field updates only.

|`inserted`
|_(none)_
|Filter to insert events only.

|`and`
|`Predicate<T> predicate`
|Add custom filter predicates; can be chained.
|===

==== Using `entityChange` method [[using-entitychange-method]]

===== Direct Entity Monitoring

**Problem**: the checker monitors the same type it operates on.
**Solution**:

[source,java]
----
registry.entityChange().updated("status");
----

.When to use
[.unstyled]
* {ok} Trigger entity == target entity
* {ok} Direct field monitoring
* {ok} Simple relationship context

===== Related Entity Monitoring

**Problem**: monitor a related entity and map to the target.

[source,java]
----
registry.entityChange(Participant.class, Participant::getApplication)
        .updated("status");
----

[.unstyled]
* {ok} Direct JPA relationships (1:1, N:1)
* {ok} Same transaction context
* {ok} Clear getter mapping

===== Complex Repository-Based Mapping

**Problem**: mapping requires repository lookup.

[source,java]
----
registry.entityChange(SignableDocument.class,
        d -> participantRepository.getReferenceById(d.getOwnerId()))
        .updated("status");
----

[NOTE]
====
**Performance**: repository lookups add DB queries — use only if no direct association is available.
====

== Checker Implementation Examples

=== BorrowerStartTreeChecker

Manages borrower workflow initiation when participants complete required documentation.

[cols="1,3",options="header"]
|===
|Component |Description

|**Target Entity** |`Participant`
|**Purpose** |Auto-start decision tree when borrower completes requirements
|**Triggers** |Document signatures and required uploads
|**Business Logic** |Set status to `IN_PROCESS`, start decision tree
|===

==== Listener 1: Application Form Signature Monitor

**Purpose**: Track completion of form signatures +
**Trigger**: `SignableDocument.status` → `SIGNED` +
**Target**: Map document → owning participant

[source,java]
----
include::{sourcedir}/participant/checker/BorrowerStartTreeChecker.java[tags=signature-listener]
----

==== Listener 2: Required Document Upload Monitor

**Purpose**: Detect required document uploads +
**Trigger**: New `EntityDocument` insertions of required types +
**Target**: Map upload → owning participant

[source,java]
----
include::{sourcedir}/participant/checker/BorrowerStartTreeChecker.java[tags=document-listener]
----

==== Availability Check

[source,java]
----
include::{sourcedir}/participant/checker/BorrowerStartTreeChecker.java[tags=availability]
----

.Availability conditions
[.unstyled]
* {ok} Participant is a `BORROWER`
* {ok} Status is `NEW`
* {ok} Application form is signed
* {ok} All required documents uploaded

==== Business Logic

[source,java]
----
include::{sourcedir}/participant/checker/BorrowerStartTreeChecker.java[tags=perform]
----

.Business operations
[.unstyled]
* {ok} **Status Update** — `NEW` → `IN_PROCESS`
* {ok} **Process Initiation** — start automated decision tree
* {ok} **Transaction Safety** — single transaction

== Best Practices

=== Design & Registration
[.unstyled]
* {ok} **Listen narrowly** — subscribe only to fields/states that matter
* {ok} **Prefer direct mapping** — use entity associations before repo lookups
* {ok} **Add predicates** — guard with `and(...)` to avoid noisy triggers
* {ok} **Idempotent perform()** — safe on duplicate events/retries

=== Availability & Logic
[.unstyled]
* {ok} **Cheap `isAvailable()`** — avoid heavy queries here
* {ok} **Fail fast** — validate required state early
* {ok} **Keep `perform()` focused** — one responsibility; delegate services

=== Observability
[.unstyled]
* {ok} **Structured logs** — entity id, event type, fields, decision
* {ok} **Metrics** — activations, successes, skips, failures
* {ok} **Tracing** — link to transaction / workflow ids

== Anti-Patterns

[.unstyled]
* {bad} **Using broad listeners** — catching all updates without field filters
* {bad} **Heavy logic in `isAvailable()`** — long DB scans/joins
* {bad} **Side-effects in availability** — mutate state during checks
* {bad} **Repository mapping by default** — use only when no direct relation
* {bad} **Non-idempotent `perform()`** — repeated activations break state
* {bad} **Silent failures** — no logs/metrics on skip/error

== Production Checklist

[.unstyled]
* {todo} Narrow listeners to specific fields/states
* {todo} Add `and(...)` predicates to reduce noise
* {todo} Make `perform()` idempotent and transactional
* {todo} Ensure `isAvailable()` is read-only and fast
* {todo} Add logs/metrics/tracing for decisions
* {todo} Cover repo-mapping paths with tests and caching
* {todo} Backpressure / retry strategy for downstream workflows